#!/usr/local/bin/python2

import numpy as np
import cv2

def detectBlobs(im):
    """ Takes and image and locates the potential location(s) of the red marker
        on top of the robot

    Hint: bgr is the standard color space for images in OpenCV, but other color
          spaces may yield better results

    Note: you are allowed to use OpenCV function calls here

    Returns:
      keypoints: the keypoints returned by the SimpleBlobDetector, each of these
                 keypoints has pt and size values that should be used as
                 measurements for the particle filter
    """

    #YOUR CODE HERE
    _,im = cv2.threshold(im[:,:,1], 140, 170, cv2.THRESH_BINARY)

    params = cv2.SimpleBlobDetector_Params()
    params.filterByArea = True
    params.minArea = 100
    params.maxArea = 10000000000
    params.filterByCircularity = False
    params.filterByColor = False
    params.filterByConvexity = False
    params.filterByInertia = False

    keypoints = cv2.SimpleBlobDetector(params).detect(im)
    return keypoints

def predict(particles, predictSigma):
    """ Predict particles one step forward. The motion model should be additive
        Gaussian noise with sigma predictSigma

    Returns:
      particles: list of predicted particles (same size as input particles)
    """

    #YOUR CODE HERE
    for p in particles:
        p[0] = np.random.normal(p[0], predictSigma)
        p[1] = np.random.normal(p[1], predictSigma)

    return particles

def update(particles, weights, keypoints):
    """ Resample particles and update weights accordingly after particle filter
        update

    Returns:
      newParticles: list of resampled partcles of type np.array
      weights: weights updated after sampling
    """

    #YOUR CODE HERE
    weights = []
    for particle in particles:
        arr = []
        for keypoint in keypoints:
            arr.append(np.linalg.norm(particle-np.asarray(keypoint.pt)))
        weights.append(1 / np.math.pow(min(arr), 3))

    weights = weights / np.sum(weights)
    return particles, weights

def resample(particles, weights):
    """ Resample particles and update weights accordingly after particle filter
        update

    Returns:
      newParticles: list of resampled partcles of type np.array
      wegiths: weights updated after sampling
    """

    #YOUR CODE HERE
    l = particles.shape[0]
    weights = weights / np.sum(weights)

    density = np.zeros(l)
    density[0] = weights[0]
    for i in range(1, l):
        density[i] = weights[i] + density[i - 1]

    for i in range(0, l):
        arr = np.asarray(density) - np.random.rand(1)[0]
        arr[arr < 0] = 1
        particles[i] = particles[arr.argmin()]
        weights[i] = weights[arr.argmin()]

    return particles, weights/np.sum(weights)

def visualizeParticles(im, particles, weights, color=(0,0,255)):
    """ Plot particles as circles with radius proportional to weight, which
        should be [0-1], (default color is red). Also plots weighted average
        of particles as blue circle. Particles should be a numpy.ndarray of
        [x, y] particle locations.

    Returns:
      im: image with particles overlaid as red circles
    """
    im_with_particles = im.copy()
    s = (0, 0)
    for i in range(0, len(particles)):
        s += particles[i]*weights[i]
        cv2.circle(im_with_particles, tuple(particles[i].astype(int)), radius=int(weights[i]*250), color=(0,0,255), thickness=3)
    cv2.circle(im_with_particles, tuple(s.astype(int)), radius=3, color=(255,0,0), thickness=6)
    return im_with_particles

def visualizeKeypoints(im, keypoints, color=(0,255,0)):
    """ Draw keypoints generated by blob detector on image in color specified
        (default is green)

    Returns:
      im_with_keypoints: the image with keypoints overlaid
    """
    # cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS ensures the size of the circle corresponds to the size of blob
    im_with_keypoints = cv2.drawKeypoints(im, keypoints, np.array([]), color, cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    return im_with_keypoints

if __name__ == "__main__":
    """ Iterate through a dataset of sequential images and use a blob detector and
        particle filter to track the robot(s) visible in the images. A couple
        helper functions were included to visualize blob keypoints and particles.

    """

    #some initial variables you can use
    imageSet='ImageSet2'
    imageWidth = 1280
    imageHeight = 800
    numParticles = 1000
    initialScale = 50
    predictionSigma = 150
    #x0 = np.array([600, 300])  #seed location for particles
    #particles = [] #YOUR CODE HERE: make some normally distributed particles
    #weights = [] #YOUR CODE HERE: make some weights to go along with the particles

    x = np.random.uniform(0, imageWidth, (numParticles, 1))
    y = np.random.uniform(0, imageHeight, (numParticles, 1))
    particles = np.concatenate((x,y), axis=1)
    weights = np.ones(numParticles)/numParticles

    for i in range(0, 19):
        #read in next image
        im = cv2.imread(imageSet+'/'+imageSet+'_' + '%02d.jpg'%i)
        yuv = cv2.cvtColor(im, cv2.COLOR_BGR2YUV)

        #visualize particles
        im_to_show = visualizeParticles(im, particles, weights)
        cv2.imshow("Current Particles", im_to_show)
        cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'1_Current.jpg', im_to_show)

        #predict forward
        particles = predict(particles, predictionSigma)
        im_to_show = visualizeParticles(im, particles, weights)
        cv2.imshow("Prediction", im_to_show)
        cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'2_Predicted.jpg', im_to_show)

        #detected keypoint in measurement
        keypoints = detectBlobs(yuv)

        #update paticleFilter using measurement if there was one
        if keypoints:
          particles, weights = update(particles, weights, keypoints)

        im_to_show = visualizeKeypoints(im, keypoints)
        im_to_show = visualizeParticles(im_to_show, particles, weights)
        cv2.imshow("Reweighted", im_to_show)
        cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'3_Reweighted.jpg', im_to_show)

        #resample particles
        particles, weights = resample(particles, weights)
        im_to_show = visualizeKeypoints(im, keypoints)
        im_to_show = visualizeParticles(im_to_show, particles, weights)
        cv2.imshow("Resampled", im_to_show)
        cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'4_Resampled.jpg', im_to_show)
        cv2.waitKey(0)
